[{"content":"In a distributed software system, computers can only communicate through network. Here are the key issues in a distrubted software system that is not present in non-distributed ones:\n Network is intrinsically unrealiable and network calls are unbounded. Clocks on different nodes are not in sync and there is no global clock time can be obtained as ground truth. Nodes and processes can fail or pause at any time for any reason.  However, we still assume that the behavior of nodes and software will follow pre-defined protocols and Byzantine fault are generally not considered. Single node\u0026rsquo;s state and communication to others can not be trusted, therefore the state of system can only be determined by a concensus of observations from majority of the nodes.\n","permalink":"https://codecoffeeclimb.github.io/posts/the-trouble-with-distributed-systems/","summary":"In a distributed software system, computers can only communicate through network. Here are the key issues in a distrubted software system that is not present in non-distributed ones:\n Network is intrinsically unrealiable and network calls are unbounded. Clocks on different nodes are not in sync and there is no global clock time can be obtained as ground truth. Nodes and processes can fail or pause at any time for any reason.","title":"The Trouble With Distributed Systems"},{"content":"If you only want to read one book for system design interview, then this is the book - Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems.\n\nThis book covers almost all aspects of what you need to know about a modern distributed software system with right depth and examples. Read it as many times as you can, then you will be all set for system design interview.\n","permalink":"https://codecoffeeclimb.github.io/posts/the-ultimate-book-of-system-design-interview/","summary":"If you only want to read one book for system design interview, then this is the book - Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems.\n\nThis book covers almost all aspects of what you need to know about a modern distributed software system with right depth and examples. Read it as many times as you can, then you will be all set for system design interview.","title":"The Ultimate Book of System Design Interview"},{"content":"As a software developer, you should know following numbers to help you understand how your software performs in big picture. The point here is not to remember these numbers exactly, but to have a sense of relative magnitude. For example, reading from memory is 100,000 times faster than reading from disk (10 ms disk seek in this case). So you should always try to read from memory rather than disk and having a memory cache can really boost the performance.\nL1 cache reference ......................... 0.5 ns Branch mispredict ............................ 5 ns L2 cache reference ........................... 7 ns Mutex lock/unlock ........................... 25 ns Main memory reference ...................... 100 ns Compress 1K bytes with Zippy ............. 3,000 ns = 3 µs Send 2K bytes over 1 Gbps network ....... 20,000 ns = 20 µs SSD random read ........................ 150,000 ns = 150 µs Read 1 MB sequentially from memory ..... 250,000 ns = 250 µs Round trip within same datacenter ...... 500,000 ns = 0.5 ms Read 1 MB sequentially from SSD* ..... 1,000,000 ns = 1 ms Disk seek ........................... 10,000,000 ns = 10 ms Read 1 MB sequentially from disk .... 20,000,000 ns = 20 ms Send packet CA-\u0026gt;Netherlands-\u0026gt;CA .... 150,000,000 ns = 150 ms On other hand, these numbers change over time too (heck out this link https://colin-scott.github.io/personal_website/research/interactive_latency.html). For example, the time of sending 2KB data over commodity network has reduced by ~25 times over the past ten years, and it is even faster than reading from disk now. Because of this, the concept of data locality that Hadoop originally was built upon no longer holds. Therefore, decoupled compute and storage architecture, like AWS EMR with S3 is getting more and more popular nowadays.\nYou should review these numbers from time to time, and you will be always on top of your software\u0026rsquo;s performance.\n","permalink":"https://codecoffeeclimb.github.io/posts/latency-numbers-every-programmer-should-know/","summary":"As a software developer, you should know following numbers to help you understand how your software performs in big picture. The point here is not to remember these numbers exactly, but to have a sense of relative magnitude. For example, reading from memory is 100,000 times faster than reading from disk (10 ms disk seek in this case). So you should always try to read from memory rather than disk and having a memory cache can really boost the performance.","title":"Latency Numbers Every Programmer Should Know"},{"content":"Just Enough for Interview is a blog post series that tries to cover the common technical programming interview topics with just right amount of information. It does not mean to give in depth explaination, nor is it needed during a typical job interview session. However, by demonstrating just right level of familarity to the topics, it can really makes you stand out from other candidates and elevate you to the next job level.\nSo, if you like it or find it useful, please share it with your friends.\n","permalink":"https://codecoffeeclimb.github.io/posts/just-enough-for-interview/","summary":"Just Enough for Interview is a blog post series that tries to cover the common technical programming interview topics with just right amount of information. It does not mean to give in depth explaination, nor is it needed during a typical job interview session. However, by demonstrating just right level of familarity to the topics, it can really makes you stand out from other candidates and elevate you to the next job level.","title":"Just Enough for Interview"}]